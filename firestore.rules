rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)).data.isAdmin == true;
    }
    
    // Anyone can read an access code to validate it, but not list all codes.
    // This allows the client-side to check if a code is valid and not used.
    function canValidateAccessCode(code) {
        return exists(/databases/$(database)/documents/access_codes/$(code));
    }

    match /customers/{customerId} {
      // Only admins can read, list, create, or delete customer records.
      allow read, list, create, delete: if isAdmin();
      // No updates allowed by clients to prevent tampering.
      allow update: if false;
    }

    match /access_codes/{accessCodeId} {
      // Admins can manage the entire lifecycle of access codes.
      allow read, list, create, delete: if isAdmin();
      
      // A user (authenticated or anonymous) can update a code ONLY to mark it as used.
      // This is the core of the single-use logic.
      // 1. The code must not have been used before (isUsed is false).
      // 2. The update can only change isUsed to true.
      // 3. No other fields can be changed.
      allow update: if request.resource.data.isUsed == true &&
                       resource.data.isUsed == false &&
                       request.resource.data.keys().hasOnly(['isUsed', 'usedAt', 'code', 'createdAt']);
    }
    
    match /roles_admin/{userId} {
      // Admins can see who other admins are.
      allow get, list: if isAdmin();
      // Role management is locked down from the client to prevent privilege escalation.
      // Roles must be assigned via the Firebase Console.
      allow create, update, delete: if false;
    }
  }
}
